# Intelligent Commerce

## 목차
1. [프로젝트 소개](#1-프로젝트-소개)
2. [프로젝트 설계](#2-프로젝트-설계)
3. [고민점](#3-고민점)
4. [고도화 예정](#4-고도화-예정)

## 1. 프로젝트 소개
### 소개
* 해당 프로젝트는 오픈마켓 플랫폼입니다.
* 상품을 주문하는 과정까지 담아보았습니다.
* 조회하는 쿼리가 많고, 연관관계가 복잡해서 쿼리의 성능을 높이고, 고민하는데에 시간을 많이 사용했습니다.
* 기존에 자바로만 만들었던 프로젝트를 간결하고 함수형을 지원하는 코틀린을 사용해 제작하였습니다.
### 기술 스택
* Framework : Spring Boot 3.1.1
* Lang : Kotlin, Jvm17
* Data : Spring Data Jpa & Kotlin-Jdsl & MySql
* Security : Spring Security & Jwt
* Test : Junit5

## 2. 프로젝트 설계
### 시스템 설계
* [아키텍처 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/ARCITECTURE.md)
* [DB 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/DB_DESIGN.md)
### 엔티티 설계
* [회원 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/MEMBER_DESIGN.md)
* [마일리지 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/MILEAGE_DESIGN.md)
* [상점 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/SHOP_DESIGN.md)
* [상품 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/ITEM_DESIGN.md)
* [주문 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/ORDER_DESIGN.md)
* [리뷰 설계](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/REVIEW_DESIGN.md)
### 흐름도
* [전체 흐름도](https://github.com/liveforone/intelligent_commerce/blob/master/Documents/FLOW.md)

## 3. 고민점
* [좋은 조인 쿼리]()
* [조인 쿼리 성능 높이기]

## 4. 고도화 예정
* 장바구니 추가
* 관련 상품 추천

고민 -> 상품안에 상점 안에 판매자가 저장되어있는데, 쿼리도 한번더 나가는게 그렇고, 그거 조회하려고 너무 깊게 조인하는 것도 그렇고
사용할때 체이닝처럼 길게 늘어지는 코드도 그렇고, 차라리 주문에 한번 더 저장하는 것은 어떨까?
데이터의 일관성등 무결성 조건들이 (정합성이) 깨질수 있음
다만 성능을 훨씬 좋고, 효율적임

## 고도화
쿼리 성능 최적화 -> 여러번의 조인을 필드에 넣어서 단건 조회 쿼리로 변경 등등 함수를 이용한 업그레이드, 구조 변경으로 업그레이드
고도화 시에는 불필요한 쿼리, 즉 체크하지 않고 함수를 호출하는 행위등을 잡아내고
성능을 따지고, 클린코드를 따지고, 모듈화하고, 확장성있게 만든다.

## 조인 의문
* dto 프로젝션시에는 조인이 필요없는데,
* 그냥 엔티티를 조회하는경우 조인을 하지 않으면 조회하지 않아도 쿼리가 나감..

## fk 값 원하는 값으로
* fk의 값을 원하는 값으로 둘때에 주의할점은 해당 값이 fk로써 적절한지이다.
* 기본값이 pk인 이유는 해당값은 변경 불가능하기 때문이다. 이러한 조건을 가져야한다.

## 조인 결론
* 객체가 가지고 있는 연관 객체의 fk를 가져올때에는 nestedCol()을 사용하면된다.
* 그런데 연관 객체의 연관 객체의 연관 객체의... 처럼 연관객체에서 그치지 않고 더 깊이 들어가는 경우나
* 연관객체의 fk 이외의 필드를 사용하기 위해서는 join을 해야만 한다.
* dto로 가져올때에는 fetch join이 안되기 때문에 일반 join과 lazy를 사용한다.
* 페치조인은 eager 로딩 처럼 연관 객체를 조인하여 단 한번의 쿼리로 가져온다.(모두 가져온다.)
* 즉 참조하는 객체까지 모두 join해야한다. 그렇지 않으면 lazy로딩의 경우 객체를 참조하는 순간 조회쿼리가 또나간다.
* 연관관계가 있다고 무조건 조인할 필요는 없다. 사용하지 않는 경우에는 조인하지 않아도 된다.
* 업데이트에 필요한 엔티티 조회 쿼리가 아니라면, dto projection을 사용해서 몇번의 multiple join을 해도
* 내가 조회하고자 하는 컬럼만 가져올 수 있도록 하여 성능으 높여라
* 조인쿼리의 경우 최종적으로 조인하고자 객체를 조인한다고 명명한다. 
* 예를들어 item을 조회하면서 연관객체인 shop의 필드인 seller를 사용한다면
* findItemJoinSeller와 같이 한다.
* 이러한 네이밍은 무조건 사용하는것이 아니라, 연관객체의 필드를 사용하는경우에는 join을 명명하지 않는다.
* 다중 조인이 발생하는 순간 명명한다.
* oneToOne의 경우 unique와 updateable 제약조건 반드시 명시
* 이외의 다대일의 경우 updateable만 명시
* nestedCol 사용할 컬럼으로 반드시 지정
* 다중 조인은 피하라. 쿼리를 깊게 생각해야해서 연관객체찾느라고 객체지향이 깨져버린다.
* 차라리 사용할 컬럼을 중복하여 엔티티에 fk로 저장하는것이 조인 + 조인 + 조인....보다 훨 낫다.

## response
* 컨트롤러메서드는 ResponseEntity<*>, 즉 와일드카드를 사용한다.
* 와일드 카드는 사실상 any 이기 때문에, 어떠한 결과가 들어가던 자동매핑된다.
* 다만 성능은 직접 명시하는것보다 떨어질것이다. 그러나 와일드 카드를 사용하는 이유는 예외처리가 작동하면서
* 다양한 형태의 respones가 리턴되기 때문이다.
* 그러나 Response 객체를 만들어서 각 컨트롤러 메서드의 성공시 리턴할 response를 모듈화시키는 경우에는
* 반드시 성공하기 때문에 타입을 명시하여 약간이나마 성능을 올리도록 한다.

## 조인 쿼리 성능 확인
컬렉션 조인 쿼리 몇개 나가나 확인하고,
두개 나가면 join을 없애고 그냥 연관 엔티티를 사용해보기
문제없고 쿼리 하나나가면 그렇게 작성
현재까지 나온건 shop id를 가져오는 경우에는 조인 필요없고, 조인 쿼리도 안나감
따라서 연관 엔티티의 필드값이 필요하다면 조인하고, 그렇지 않다면 조인 하지 말아라.
즉 메서드도 두가지로 나누어야한다.

## 쿼리
a와 b가 연관관계가 있을때
a만을 조회할때에는 문제가 없으나, lazy 로딩일지라도
조인을 하지 않게되면 a만 가져온다.
따라서 a.b.id를 하여 b의 id를 가져오게되면 b를 조회하는 쿼리가 나간다.
따라서 이렇게 사용될 일이 있는 경우에는 fetch join을 하여 미리 lazy로 가져오고 사용하면 훨씬 성능이 좋아진다.

## 로직
마일리지는 일반회원의 경우자동생성
상점은 셀러만 생성 가능하지만, 따로 신청하도록함.
회원 정보조회에 여러 api 콜을 하도록함. -> 마일리지 api 따로 만듦.

## 느낀 점
* dto는 fetch join하지 않는다.
* 에러를 핸들링할때 exception message에 status도 넣어서 관리하기
* 테스트시에 flush()와 clear()는 함수를 따로 만들어서 가독성 향상하기
* 연관관계 삭제시, delte method 만들지 말고, jpa에서 제공하는 delete() 함수


## 연관게시물
* 연관게시물을 뽑는 간단하며 좋은 방법은 검색이다.
* 다만 인덱스를 타지 않는 %% 검색을 사용해야하고
* 4개정도를 뽑아오는 방식으로 한다.


장바구니는 구현가능함
cart만들고 리스트로 뽑아오면됨.
문제는 장바구니가 수익창출의 수단으로써 가치가 없다는것
[이유]
Statista의 조사에 따르면 장바구니에 상품을 담은 후 이탈하는 상품 비율은 약 88%(2020년 기준)에 이른다고 합니다. 또 한국인들은 상품을 장바구니에 담고 ‘구매’ 클릭을 결정하기까지 소요되는 시간은 당일 완료하는 경우 54%, 1일 이상 고민하는 경우가 46%로 절반 정도입니다. 1주일 혹은 그 이상 걸리는 소비자는 무려 4분의 1 정도에 가까웠습니다.또한 장바구니 결제를 포기하는 이유는 62%의 응답자가 '다른 브랜드 및 웹사이트와 가격을 비교하기 위해 온라인 장바구니를 이용하기 때문'이라고 답했습니다. 장바구니는 구매 결정을 최종적으로 할 때, 더 저렴하거나 혜택 좋은 상품 비교를 하는 마지막 단계라고 볼 수 있습니다. 이처럼 장바구니는 마지막 구매 전환의 단계로써 핵심적인 역할을 하고 있습니다.
[구매 전환율을 올리기위해 필요한것]
장바구니에 담았을 때 해당하는 상품과 관련된 쿠폰을 제공
무료배송 혜택을 강조
구매할 수 있는 연관된 상품을 추천
장바구니에 있는 상품들을 상기
여기에는 없지만 필자의 생각인 빠른 결제로아예 빠르게 결제를 끝내서 상품에 대한 생각을 잊어버리는것